import chess
import time
import random
import collections 
from collections import defaultdict

class TranspositionTable:
    """Lop bang luu cac trang thai da danh gia de tang toc do.
    Gom : Exact,Lower, Upper"""
    def __init__(self):
        self.table = {}
    
    def store(self,key,depth,flag,score,best_move):
        current = self.table.get(key)
        
        # giu lai entry tot hon (tie-breaking: prefer deeper searches)
        if current is None or depth >= current[0]:
            self.table[key] = (depth,flag,score,best_move)
            
    def probe(self,key,depth,alpha,beta):
        """Tra TT de xem co the su dung ket qua truoc do khong."""
        entry = self.table.get(key)
        if entry is None:
            return None
        edepth,flag,val,mmove = entry
        if edepth < depth:
            return None # Do sau khong du lon
            
        if flag == 'EXACT':
            return val, mmove,flag
        if flag == 'LOWER' and val >= beta:
            return val, mmove,flag
        if flag == 'UPPER' and val <= alpha:
            return val, mmove,flag
        return None

class ChessEngine:
    def __init__(self):
        print("--- 100% ĐANG CHẠY CODE ENGINE MỚI NHẤT! ---")
        self.board = chess.Board()

        self.state = None
        # transposition cache (fen, depth, is_maximizing) -> (score, best_move)
# ...existing code...
class ChessEngine:
    def __init__(self):
        print("--- 100% ĐANG CHẠY CODE ENGINE MỚI NHẤT! ---")
        # start position
        self.board = chess.Board()
        self.state = None

        # --- Khởi tạo mặc định cho engine (tránh AttributeError khi gọi best_move) ---
        # Giá trị cơ bản cho các quân
        self.piece_values = {
            chess.PAWN: 100,
            chess.KNIGHT: 320,
            chess.BISHOP: 330,

        
        # --- ĐIỂM VẬT CHẤT CHUYÊN NGHIỆP ---
        self.piece_values = {
            chess.PAWN: 100,
            chess.KNIGHT: 320,
            chess.BISHOP: 330, 

            chess.ROOK: 500,
            chess.QUEEN: 900,
            chess.KING: 20000
        }

        # Trọng số mobility mặc định
        self.mobility_weights = {
            chess.PAWN: 1,
            chess.KNIGHT: 4,
            chess.BISHOP: 4,
            chess.ROOK: 3,
            chess.QUEEN: 2,
            chess.KING: 1
        }
        # PSTs, zobrist, transposition table, killer/history, timeout
        try:
            self.__init___piece_square_tables()
        except Exception:
            # nếu có lỗi lúc khởi tạo PST thì bỏ qua nhưng tiếp tục khởi tạo các cấu trúc khác
            pass
        self._init_zobrist()
        self.tt = TranspositionTable()
        self.killers = defaultdict(lambda: [None, None])
        self.history = defaultdict(int)
        self.stop_time = None

       

        
        # --- ĐIỂM THƯỞNG CẶP QUÂN ---
        self.BISHOP_PAIR_BONUS = 50 
        
        self.mobility_weights = {
            chess.PAWN: 1, 
            chess.KNIGHT: 4, 
            chess.BISHOP: 4, 
            chess.ROOK: 3, 
            chess.QUEEN: 2, 
            chess.KING: 1 
        }
        
        self._init_piece_square_tables()
        
        self._init_zobrist()
        self.tt = TranspositionTable()
        self.killers = defaultdict(lambda: [None, None]) 
        self.history = defaultdict(int) 
        
        self.stop_time = None


  
    def print_board(self):
        print(self.board)

    def _init_zobrist(self):
        """Khoi tao bang Zobrist cho hash nhanh."""
        self.zobrist_piece = {}
        for pt in (chess.PAWN,chess.KNIGHT,chess.BISHOP,chess.ROOK,chess.QUEEN,chess.KING):
            for color in (chess.WHITE,chess.BLACK):
                for sq in chess.SQUARES:
                    self.zobrist_piece[(pt,color,sq)] = random.getrandbits(64)
        self.zobrist_side = random.getrandbits(64)
        self.zobrist_castle = {
            'K' : random.getrandbits(64),
            'Q' : random.getrandbits(64),
            'k' : random.getrandbits(64),
            'q' : random.getrandbits(64),
        }
        self.zobrist_ep = [random.getrandbits(64) for _ in range(8)]
        
    def zobrist_hash(self):
        """Tinh hash Zobrist cho trang thai hien tai cua ban co."""
        h =0
        for sq in chess.SQUARES:
            piece = self.board.piece_at(sq)
            if piece:
                h ^= self.zobrist_piece[(piece.piece_type,piece.color,sq)]
        if self.board.turn == chess.BLACK:
            h ^= self.zobrist_side
        if self.board.has_kingside_castling_rights(chess.WHITE):
            h ^= self.zobrist_castle['K']
        if self.board.has_queenside_castling_rights(chess.WHITE):
            h ^= self.zobrist_castle['Q']
        if self.board.has_kingside_castling_rights(chess.BLACK):
            h ^= self.zobrist_castle['k']
        if self.board.has_queenside_castling_rights(chess.BLACK):
            h ^= self.zobrist_castle['q']
        ep = self.board.ep_square
        if ep is not None:
            f = chess.square_file(ep)
            h ^= self.zobrist_ep[f]
        return h
        
        
    #---------------------------------------
    # 1. EVALUATION ENTRY POINT
    #---------------------------------------
    def evaluate_board(self):
    
        # Kiểm tra trạng thái kết thúc trò chơi
        if self.board.is_checkmate():
            return -99999 if self.board.turn == chess.WHITE else 99999
        # Xử lý các trường hợp hòa: Tuyệt đối không thay đổi dòng này.
        if self.board.is_stalemate() or self.board.is_insufficient_material() or self.board.is_fifty_moves() or self.board.is_repetition():
            return 0

        game_phase = self._get_game_phase_taper()
            
        material_pst = self._material_eval() # Bao gồm vật chất và PST
        
        # Bổ sung các yếu tố đánh giá chuyên nghiệp
        bishop_pair = self._bishop_pair_eval() # Điểm cặp Tượng
        mobility = self._mobility_eval() 
        pawn_struct = self._pawn_structure_eval()
        center = self._center_control_eval()
        king_safety = self._king_safety_eval() 
        
        # Áp dụng Tapering cho King Safety (chỉ quan trọng ở Trung cuộc)
        max_phase = 24
        # King safety chỉ áp dụng nếu game chưa quá tàn cuộc
        tapered_king_safety = (king_safety * game_phase) // max_phase if game_phase > 4 else 0

        score = (
            material_pst + 
            bishop_pair +
            mobility +
            pawn_struct +
            center +
            tapered_king_safety 
        )
        
        return int(score)
    
    # --- PHƯƠNG THỨC BỔ SUNG ĐIỂM CẶP TƯỢNG ---
    def _bishop_pair_eval(self):
        """Thưởng điểm cho việc sở hữu cặp Tượng (Bishop Pair)."""
        score = 0
        
        white_bishops = len(self.board.pieces(chess.BISHOP, chess.WHITE))
        black_bishops = len(self.board.pieces(chess.BISHOP, chess.BLACK))
        
        if white_bishops >= 2:
            score += self.BISHOP_PAIR_BONUS
        if black_bishops >= 2:
            score -= self.BISHOP_PAIR_BONUS
            
        return score
    
    # --- PSTS, MOBILITY, PAWN STRUCTURE, KING SAFETY (GIỮ NGUYÊN) ---

    def _mobility_eval(self):
        """Đánh giá khả năng di chuyển của các quân cờ"""
        score = 0
        for sq,piece in self.board.piece_map().items():
            if piece.piece_type == chess.PAWN:
                continue
            
            attacks = len(self.board.attacks(sq))
            w = self.mobility_weights.get(piece.piece_type, 0)
            
            if piece.color == chess.WHITE:
                score += attacks * w
            else:
                score -= attacks * w
        return score

    def _pawn_structure_eval(self):
        """Đánh giá cấu trúc tốt (Doubled, Isolated, Passed, Protected)."""
        score = 0
        
        white_pawns = set(self.board.pieces(chess.PAWN, chess.WHITE))
        black_pawns = set(self.board.pieces(chess.PAWN, chess.BLACK))
        
        white_pawn_piece = chess.Piece(chess.PAWN, chess.WHITE)
        black_pawn_piece = chess.Piece(chess.PAWN, chess.BLACK)

        pawn_files_white = [chess.square_file(sq) for sq in white_pawns]
        pawn_files_black = [chess.square_file(sq) for sq in black_pawns]
        
        # 1. Xử lý Tốt Chồng (Doubled)
        doubled_penalty = 25
        white_file_counts = collections.Counter(pawn_files_white)
        black_file_counts = collections.Counter(pawn_files_black)
        
        for count in white_file_counts.values():
            if count > 1:
                score -= doubled_penalty * (count - 1)
        
        for count in black_file_counts.values():
            if count > 1:
                score += doubled_penalty * (count - 1)
        
        # 2. Xử lý Tốt Cô Lập (Isolated)
        isolated_penalty = 20
        white_file_set = set(pawn_files_white)
        black_file_set = set(pawn_files_black)
        
        for f in white_file_set:
            if (f - 1) not in white_file_set and (f + 1) not in white_file_set:
                score -= isolated_penalty * white_file_counts[f]
        
        for f in black_file_set:
            if (f - 1) not in black_file_set and (f + 1) not in black_file_set:
                score += isolated_penalty * black_file_counts[f]

        # Hàm is_passed
        def is_passed(sq, color, my_pawns, enemy_pawns):
            f = chess.square_file(sq)
            r = chess.square_rank(sq)
        
            for ep in enemy_pawns:
                ef = chess.square_file(ep)
                er = chess.square_rank(ep)
                if abs(ef - f) <= 1:
                    if (color == chess.WHITE and er > r) or (color == chess.BLACK and er < r):
                        return False
            return True

        # 3. Xử lý Tốt Thông (Passed) và Tốt Được Bảo Vệ (Protected)
        passed_bonus = 25
        protected_bonus = 10 

        for sq in white_pawns:
            if is_passed(sq, chess.WHITE, white_pawns, black_pawns):
                rank = chess.square_rank(sq)
                score += passed_bonus + (rank - 1) * 15 
        
            r = chess.square_rank(sq)
            f = chess.square_file(sq)
            if r > 0: 
                if f > 0 and self.board.piece_at(chess.square(f - 1, r - 1)) == white_pawn_piece:
                    score += protected_bonus
                if f < 7 and self.board.piece_at(chess.square(f + 1, r - 1)) == white_pawn_piece:
                    score += protected_bonus
        
        for sq in black_pawns:
            if is_passed(sq, chess.BLACK, black_pawns, white_pawns):
                rank = chess.square_rank(sq)
                score -= (passed_bonus + (6 - rank) * 15) 
        
            r = chess.square_rank(sq)
            f = chess.square_file(sq)
            if r < 7: 
                if f > 0 and self.board.piece_at(chess.square(f - 1, r + 1)) == black_pawn_piece:
                    score -= protected_bonus
                if f < 7 and self.board.piece_at(chess.square(f + 1, r + 1)) == black_pawn_piece:
                    score -= protected_bonus

        return score

    def _center_control_eval(self):
        """Đánh giá kiểm soát trung tâm (d4, d5, e4, e5)"""
        score = 0
        center_squares = (chess.D4, chess.D5, chess.E4, chess.E5)
        
        for sq in center_squares:
            p = self.board.piece_at(sq)
            if p:
                score += 30 if p.color == chess.WHITE else -30
                
            white_attackers = len(self.board.attackers(chess.WHITE, sq))
            black_attackers = len(self.board.attackers(chess.BLACK, sq))
            score += (white_attackers - black_attackers) * 8
            
        return score

    def _init_piece_square_tables(self): 
        """Khởi tạo PSTs (Piece Square Tables) cho Trung cuộc (MG) và Tàn cuộc (EG)."""
        # Bảng Vua Trung cuộc: Khuyến khích nhập thành (ô g1, c1)
        KING_MG_PST = [
        -30,-40,-40,-50,-50,-40,-40,-30, 
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-40,-40,-50,-50,-40,-40,-30,
        -20,-30,-30,-40,-40,-30,-30,-20,
        -10,-20,-20,-20,-20,-20,-20,-10,
        20, 20, 0, 0, 0, 0, 20, 20, 
        20, 30, 10, 0, 0, 10, 30, 20 
        ]
        
        # Bảng Vua Tàn cuộc: Khuyến khích trung tâm
        KING_EG_PST = [
        -50,-40,-30,-20,-20,-30,-40,-50,
        -30,-20,-10, 0, 0,-10,-20,-30,
        -30,-10, 20, 30, 30, 20,-10,-30,
        -30,-10, 30, 40, 40, 30,-10,-30,
        -30,-10, 30, 40, 40, 30,-10,-30,
        -30,-10, 20, 30, 30, 20,-10,-30,
        -30,-20,-10, 0, 0,-10,-20,-30,
        -50,-40,-30,-20,-20,-30,-40,-50
        ]
        
        # Bảng Tốt Trung cuộc
        PAWN_MG_PST = [
        0, 0, 0, 0, 0, 0, 0, 0,
        5, 10, 10, -20, -20, 10, 10, 5,
        5, -5, -10, 0, 0, -10, -5, 5,
        0, 0, 0, 20, 20, 0, 0, 0,
        5, 5, 10, 25, 25, 10, 5, 5,
        10, 10, 20, 30, 30, 20, 10, 10,
        50, 50, 50, 50, 50, 50, 50, 50,
        0, 0, 0, 0, 0, 0, 0, 0
        ]
        
        # Bảng Tốt Tàn cuộc
        PAWN_EG_PST = [
        0, 0, 0, 0, 0, 0, 0, 0,
        10, 10, 10, 10, 10, 10, 10, 10, 
        20, 20, 20, 20, 20, 20, 20, 20, 
        30, 30, 30, 30, 30, 30, 30, 30, 
        40, 40, 40, 40, 40, 40, 40, 40, 
        60, 60, 60, 60, 60, 60, 60, 60, 
        100, 100, 100, 100, 100, 100, 100, 100, 
        0, 0, 0, 0, 0, 0, 0, 0
        ]
        KNIGHT_PST = [
        -50,-40,-30,-30,-30,-30,-40,-50,
        -40,-20,0,0,0,0,-20,-40,
        -30,0,10,15,15,10,0,-30,
        -30,5,15,20,20,15,5,-30,
        -30,0,15,20,20,15,0,-30,
        -30,5,10,15,15,10,5,-30,
        -40,-20,0,5,5,0,-20,-40,
        -50,-40,-30,-30,-30,-30,-40,-50
        ]
        BISHOP_PST = [
        -20,-10,-10,-10,-10,-10,-10,-20,
        -10,0,0,0,0,0,0,-10,
        -10,0,5,10,10,5,0,-10,
        -10,5,5,10,10,5,5,-10,
        -10,0,10,10,10,10,0,-10,
        -10,10,10,10,10,10,10,-10,
        -10,5,0,0,0,0,5,-10,
        -20,-10,-10,-10,-10,-10,-10,-20
        ]
        ROOK_PST = [
        0,0,0,0,0,0,0,0,
        5,10,10,10,10,10,10,5,
        -5,0,0,0,0,0,0,-5,
        -5,0,0,0,0,0,0,-5,
        -5,0,0,0,0,0,0,-5,
        -5,0,0,0,0,0,0,-5,
        -5,0,0,0,0,0,0,-5,
        0,0,0,5,5,0,0,0
        ]
        QUEEN_PST = [
        -20,-10,-10,-5,-5,-10,-10,-20,
        -10,0,0,0,0,0,0,-10,
        -10,0,5,5,5,5,0,-10,
        -5,0,5,5,5,5,0,-5,
        0,0,5,5,5,5,0,0,
        -10,5,5,5,5,5,0,-10,
        -10,0,5,0,0,0,0,-10,
        -20,-10,-10,-5,-5,-10,-10,-20
        ]
        
        self.PST_MG = {
        chess.PAWN: PAWN_MG_PST, 
        chess.KNIGHT: KNIGHT_PST,
        chess.BISHOP: BISHOP_PST,
        chess.ROOK: ROOK_PST,
        chess.QUEEN: QUEEN_PST,
        chess.KING: KING_MG_PST 
        }
        
        self.PST_EG = {
        chess.PAWN: PAWN_EG_PST, 
        chess.BISHOP: BISHOP_PST,
        chess.KNIGHT: KNIGHT_PST,
        chess.ROOK: ROOK_PST,
        chess.QUEEN: QUEEN_PST,
        chess.KING: KING_EG_PST 
        }
    
    def _get_game_phase_taper(self):
        """Tính toán giai đoạn ván cờ (game phase taper)."""
        phase_weights = {
            chess.KNIGHT: 1,
            chess.BISHOP: 1,
            chess.ROOK: 2,
            chess.QUEEN: 4
        }
        max_phase = 24 
        
        current_phase = 0
        for piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN):
            count = len(self.board.pieces(piece_type, chess.WHITE)) + len(self.board.pieces(piece_type, chess.BLACK))
            current_phase += count * phase_weights[piece_type]
        
        current_phase = min(current_phase, max_phase)
        
        return current_phase
    
    
    def _material_eval(self): 
        """Đánh giá vật chất và bảng vị trí quân cờ (có nhận biết giai đoạn)"""
        score = 0
        phase = self._get_game_phase_taper()
        max_phase = 24 
        
        for sq in chess.SQUARES:
            piece = self.board.piece_at(sq)
            if not piece:
                continue
        
            val = self.piece_values[piece.piece_type]
            mirrored_sq = chess.square_mirror(sq)
            
            pst_mg_score = self.PST_MG[piece.piece_type][sq if piece.color == chess.WHITE else mirrored_sq]
            pst_eg_score = self.PST_EG[piece.piece_type][sq if piece.color == chess.WHITE else mirrored_sq]
            
            pst_score = ((pst_mg_score * phase) + (pst_eg_score * (max_phase - phase))) // max_phase
            
            if piece.color == chess.WHITE:
                score += val + pst_score
            else:
                score -= (val + pst_score)
        
        return score

    def _king_safety_eval(self): 
        """Đánh giá độ an toàn của vua (chủ yếu ở Trung cuộc)"""
        score = 0
        king_white_sq = self.board.king(chess.WHITE)
        king_black_sq = self.board.king(chess.BLACK)
        
        def penalty(king_sq,color):
            if king_sq is None:
                return 0
            
            file = chess.square_file(king_sq)
            rank = chess.square_rank(king_sq)
            pen = 0
            
            if rank in(3,4) or file in(3,4):
                pen += 60
                
            if color == chess.WHITE:
                front_rank = rank + 1
                start_rank = 1 
            else:
                front_rank = rank - 1
                start_rank = 6
                
            for df in [-1,0,1]:
                f = file + df
                if 0 <= f <= 7 and 0 <= front_rank <= 7:
                    sq = chess.square(f,front_rank)
                    piece = self.board.piece_at(sq)
                    if not piece or piece.piece_type != chess.PAWN or piece.color != color:
                        pen += 20
                        
            if rank == start_rank and file == 4:
                if (color == chess.WHITE and self.board.has_kingside_castling_rights(chess.WHITE) or self.board.has_queenside_castling_rights(chess.WHITE)) or \
                    (color == chess.BLACK and self.board.has_kingside_castling_rights(chess.BLACK) or self.board.has_queenside_castling_rights(chess.BLACK)):
                    pen += 20 
            
            return pen

        score -= penalty(king_white_sq,chess.WHITE)
        score += penalty(king_black_sq,chess.BLACK)
        return score
    
    def _mvv_lva_value(self,move):
        """ Ham tra ve gia tri MVV-LVA cho nuoc di (Most Valuable Victim - Least Valuable Attacker) """
        if not self.board.is_capture(move):
            return 0
        victim = self.board.piece_at(move.to_square)
        attacker = self.board.piece_at(move.from_square)
        if not victim and self.board.is_en_passant(move):
            victim = chess.Piece(chess.PAWN, not self.board.turn)
            
        if not victim or not attacker:
            return 0
            
        v = self.piece_values.get(victim.piece_type,0)
        a = self.piece_values.get(attacker.piece_type,0)
        return 10000 + (v*10 - a) 
    
    def static_exchange_eval(self, move):
        """Approximate full SEE by simulating captures on a copied board."""
        if not self.board.is_capture(move):
            return 0

        sim = self.board.copy()
        
        victim_piece = sim.piece_at(move.to_square)
        if victim_piece is None and sim.is_en_passant(move):
            victim_piece = chess.Piece(chess.PAWN, not sim.turn)
            
        victim_value = self.piece_values.get(victim_piece.piece_type, 0) if victim_piece else 0

        gains = [victim_value]

        try:
            sim.push(move)
        except Exception:
            return 0

        target = move.to_square
        
        while True:
            captures = [m for m in sim.legal_moves if m.to_square == target and sim.is_capture(m)]
            
            if not captures:
                break
                
            def attacker_value(mv):
                p = sim.piece_at(mv.from_square)
                return self.piece_values.get(p.piece_type, 0) if p else 0
                
            best = min(captures, key=attacker_value)
            
            captured = sim.piece_at(best.to_square)
            if captured is None and sim.is_en_passant(best):
                captured = chess.Piece(chess.PAWN, not sim.turn)
                
            cap_val = self.piece_values.get(captured.piece_type, 0) if captured else 0
            gains.append(cap_val)
            sim.push(best)

        net_material = 0
        for i in reversed(range(len(gains))):
            gain = gains[i]
            if i % 2 == 0: 
                net_material = gain - net_material
            else: 
                net_material = net_material - gain
        
        return net_material

    def _order_moves_improved(self, depth):
        """Sắp xếp nước đi sử dụng nhiều heuristic để cải thiện hiệu suất tìm kiếm."""
        moves = list(self.board.legal_moves)
        my_color = self.board.turn

        # TT best move
        key_tt = None
        try:
            h = self.zobrist_hash()
            tt_entry = self.tt.probe(h, depth, float('-inf'), float('inf')) 
            if tt_entry:
                key_tt = tt_entry[1] # Lấy best_move từ TT
        except Exception:
            key_tt = None

        k1, k2 = self.killers.get(depth, [None, None])

        def score_move(m):
            s = 0
            if key_tt is not None and m == key_tt:
                s += 100000
                
            s += self._mvv_lva_value(m)
            
            if m.promotion:
                s += 8000
                
            if m == k1:
                s += 5000
            elif m == k2:
                s += 4000
                
            if not self.board.is_capture(m):
                s += self.history.get((m.from_square, m.to_square), 0)
                
            if self.board.is_capture(m):
                see_val = self.static_exchange_eval(m)
                if see_val < 0:
                    s -= 20000 
                else:
                    s += min(2000, see_val * 8) 
                    
            if self.board.gives_check(m):
                s += 100
            if self.board.is_castling(m):
                s += 50
                
            return -s 

        moves.sort(key=score_move)
        return moves

    def _record_killer(self,move,depth):
        """Luu nuoc di killer vao danh sach killer moves"""
        k1,k2 = self.killers.get(depth,(None,None))
        if k1 is None:
            self.killers[depth][0] = move
            return
        elif move != k1:
            self.killers[depth][1] = k1 
            self.killers[depth][0] = move 
    
    def _record_history(self,move,depth,bonus=1):
        """Cập nhật bảng lịch sử cho nước đi"""
        key = (move.from_square, move.to_square) 
        self.history[key] += bonus * (1 << depth) 


    def qsearch(self, alpha, beta, is_maximizing):
        """Tìm kiếm tĩnh (Quiescence Search)"""
    
        if self.stop_time is not None and time.time() > self.stop_time:
            return None 

        stand_pat_score = self.evaluate_board()

        if is_maximizing:
            if stand_pat_score >= beta:
                return stand_pat_score 
            alpha = max(alpha, stand_pat_score)
            max_eval = stand_pat_score 
        else: 
            if stand_pat_score <= alpha:
                return stand_pat_score 
            beta = min(beta, stand_pat_score)
            min_eval = stand_pat_score 

        noisy_moves = [m for m in self.board.legal_moves if m.promotion is not None or self.board.is_capture(m)]
        
        noisy_moves.sort(key=lambda m: -self._mvv_lva_value(m))

        for move in noisy_moves:

            self.board.push(move)
            eval_score = self.qsearch(alpha, beta, not is_maximizing) 
            self.board.pop()

            if eval_score is None:
                return None 

            if is_maximizing:
                if eval_score > max_eval:
                    max_eval = eval_score
                alpha = max(alpha, eval_score)
                if alpha >= beta:
                    break 
            else: 
                if eval_score < min_eval:
                    min_eval = eval_score
                beta = min(beta, eval_score)
                if alpha >= beta:
                    break 

        return max_eval if is_maximizing else min_eval

    # =========================================================
    # CẤP ĐỘ DỄ: MINIMAX CƠ BẢN (KHÔNG CẮT TỈA, KHÔNG TT)
    # =========================================================
    def minimax_pure(self, depth, is_maximizing):
        """Minimax cổ điển (không Alpha-Beta, không TT)."""
        # Kiểm tra thời gian dừng
        if self.stop_time is not None and time.time() > self.stop_time:
            return None, None 
        # Điểm dừng 1: Xử lý trạng thái kết thúc trò chơi
        if self.board.is_game_over():
            return self.evaluate_board(), None
        # Điểm dừng 2: Dừng tìm kiếm theo độ sâu
        if depth == 0:
            # Dùng QSearch để ổn định đánh giá cuối cùng
            val = self.qsearch(float('-inf'), float('inf'), is_maximizing)
            if val is None:
                 return None, None
            return val, None

        best_move = None
        # Cấu trúc Minimax cơ bản
        if is_maximizing:
            max_eval = float('-inf')
            for move in self._order_moves_improved(depth):
                self.board.push(move)
                # Gọi đệ quy không có alpha/beta
                eval_score, _ = self.minimax_pure(depth - 1, False) 
                self.board.pop()
                
                if eval_score is None:

                    return None, None
                # Cập nhật điểm tối đa và nước đi tốt nhất
                if eval_score > max_eval:
                    max_eval = eval_score
                    best_move = move
            return max_eval, best_move
            
        else: # is_minimizing
            min_eval = float('inf')
            for move in self._order_moves_improved(depth):
                self.board.push(move)
                # Gọi đệ quy không có alpha/beta
                eval_score, _ = self.minimax_pure(depth - 1, True)
                self.board.pop()
                
                if eval_score is None:
                    return None, None
                
                if eval_score < min_eval:
                    min_eval = eval_score
                    best_move = move
            return min_eval, best_move


    # =========================================================
    # CẤP ĐỘ TRUNG BÌNH/KHÓ: MINIMAX + ALPHA-BETA 
    # =========================================================
    def minimax_full(self, depth, alpha, beta, is_maximizing):
        """Minimax với cắt tỉa Alpha-Beta và tất cả kỹ thuật nâng cao (TT, Killers, History)."""
        
        if self.stop_time is not None and time.time() > self.stop_time:
            return None, None 

        h = self.zobrist_hash() 
        tt_hit = self.tt.probe(h, depth, alpha, beta) 
        
        if tt_hit is not None:
            val, best_move, flag = tt_hit
            return val, best_move

        if self.board.is_game_over():
            val = self.evaluate_board()
            self.tt.store(h, depth, 'EXACT', val, None)
            return val, None

        if depth == 0:
            val = self.qsearch(alpha, beta, is_maximizing) 
            if val is None:
                 return None, None
            
            self.tt.store(h, depth, 'EXACT', val, None) 
            return val, None

        best_move = None
        alpha_orig, beta_orig = alpha, beta 
        
        if is_maximizing:
            max_eval = float('-inf')
            for move in self._order_moves_improved(depth):
                self.board.push(move)
                eval_score, _ = self.minimax_full(depth - 1, alpha, beta, False) 
                self.board.pop()
                
                if eval_score is None:

                    return None, None 
                
                if eval_score > max_eval:
                    max_eval = eval_score
                    best_move = move
                alpha = max(alpha, eval_score)
                if alpha >= beta:
                    if not self.board.is_capture(move):
                        self._record_killer(move, depth)
                        self._record_history(move, depth, bonus=1)
                    break

            
            if best_move is None: 
                return max_eval, None 


            if max_eval <= alpha_orig:
                flag = 'UPPER'
            elif max_eval >= beta_orig:
                flag = 'LOWER'
            else:
                flag = 'EXACT'
            self.tt.store(h, depth, flag, max_eval, best_move)
            return max_eval, best_move
            
        else: # is_minimizing
            min_eval = float('inf')
            for move in self._order_moves_improved(depth):
                self.board.push(move)
                eval_score, _ = self.minimax_full(depth - 1, alpha, beta, True)
                self.board.pop()
                
                if eval_score is None:

                    return None, None  

                    return None, None 

                
                if eval_score < min_eval:
                    min_eval = eval_score
                    best_move = move
                beta = min(beta, eval_score)
                if alpha >= beta:
                    if not self.board.is_capture(move):
                        self._record_killer(move, depth)
                        self._record_history(move, depth, bonus=1)
                    break

            
            if best_move is None:
                return min_eval, None

            if min_eval <= alpha_orig:
                flag = 'UPPER'
            elif min_eval >= beta_orig:
                flag = 'LOWER'
            else:
                flag = 'EXACT'
            self.tt.store(h, depth, flag, min_eval, best_move)
            return min_eval, best_move


    def best_move(self, depth=3, time_limit=5.0, mode='minimax_full'): 
        """Sử dụng thuật toán tìm kiếm tương ứng với mode và iterative deepening."""
        
        legal_moves = list(self.board.legal_moves)
        if not legal_moves:
            return None
            
        start = time.time()
        self.stop_time = start + time_limit
        last_safe_move = random.choice(legal_moves) # Nước đi an toàn khởi tạo
        
        is_maximizing_player = self.board.turn == chess.WHITE
        
        if mode == 'minimax_pure':
            # CẤP ĐỘ DỄ: Chỉ chạy Minimax thuần túy một lần ở độ sâu tối đa
            score, mv = self.minimax_pure(depth, is_maximizing_player)
            if mv is not None:
                #vị trí 1: In điểm số cho mỗi độ sâu hoàn thành (Dễ)
                print(f"DEBUG (EASY MODE): Depth={depth}, Move={mv.uci()}, Score={score}")
                return mv
            return last_safe_move

        # CẤP ĐỘ TRUNG BÌNH/KHÓ: MINIMAX + ALPHA-BETA + ID
        self.killers.clear()
        self.history.clear()
        best_score_so_far = float('-inf') if is_maximizing_player else float('inf')
        
        try:
            for current_depth in range(1, depth + 1):
                if time.time() >= self.stop_time:
                    break
                
                # Gọi hàm minimax_full
                score, mv = self.minimax_full(current_depth, float('-inf'), float('inf'), is_maximizing_player)
                
                if score is None:
                    break 

                if mv is not None:
                    if (is_maximizing_player and score >= best_score_so_far) or \
                       (not is_maximizing_player and score <= best_score_so_far):
                        best_score_so_far = score
                        last_safe_move = mv 
                # VỊ TRÍ 2: In điểm số cho mỗi độ sâu hoàn thành (Trung bình/Khó)
                    print(f"DEBUG: Depth={current_depth}, Move={mv.uci()}, Score={score}")
                if abs(best_score_so_far) >= 99999:
                    break
                    
        finally:
            self.stop_time = None 
        
        return last_safe_move